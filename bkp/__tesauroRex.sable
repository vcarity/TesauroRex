/*
* Projeto da Disciplina Compiladores 2018.2
* Alunos: Gabriel Leite, Rafael Sena e Victor Carity
* TESAURO REX, RAWWWR!!
* verificar gramÃ¡tica -> http://sablecc.org/grammars
*
* https://github.com/vcarity/TesauroRex
*
*/

Package tesauroRex;

Helpers

digit = ['0' .. '9'];
lowercase = ['a' .. 'z'];
uppercase = ['A' .. 'Z'];
underscore = '_';
dot = '.';
letter = lowercase | uppercase;
ascii = [0 .. 0xff];
nul = '\0';
bel = '\a';
bs = '\b';
ht = '\t';
np = '\f';
nl = '\n';
cr = '\r';
apostrophe = ''';
quote = '"';
ascii_table = ascii | nul | bel | bs | ht | np | nl | cr ;
boolean = '0' | '1';
number = digit+;
binary = 'b' boolean+;
decimal = 'd' number+;

Tokens

start = 'start';
finish = 'finish';
code = 'code';
unalterable = 'unalterable';
vector = 'vector';
boolean = 'boolean';
in = 'in';
case = 'case';
that = 'that';
as = 'as';
long = 'long';
considering = 'considering';
capture = 'capture';
show = 'show';
comma = ',';

/*

Nao tinha no meu lexico, estou acrescentando agora no sintatico:

*/

inttype = 'integer';
realtype = 'real';
symboltype = 'symbol';

from = 'from';
to = 'to';
by = 'by';
do = 'do';
else = 'else';


/* 

Final do que era pra ter feito no lexico

*/

assign = ':=';
assign_unalterable = '=';

end = ';';
plus = '+';
minus = '-';
mult = '*';
div = '/';
mod = '%';
equal = '==';
negation = '!=';
leq = '<=';
beq = '>=';
le = '<';
bg = '>';
not = '!';
and = 'and';
or = 'or';
xor = 'xor';

l_par = '(';
r_par = ')';
lbracket = '[';
rbracket = ']';


identifier = letter ( letter | underscore )*;

symbol = ( apostrophe ascii_table apostrophe ) | ( apostrophe apostrophe );
real = number+ dot number+;
integer = binary | decimal | number;
string = quote ( ascii* | letter* | ' ' )* quote;


blank = ( ' ' | 13 | 10)+;
comment = ( '{' ( ascii* | letter* | ' ' ) '}' );



Ignored Tokens

blank,
comment;


Productions

 programa = code identifier bloco;
 
 bloco = start declaracao* comando* finish;
 
 declaracao = {variavel} tipo ids* identifier end
 			| {constant} unalterable tipo identifier unalt_aux end;
 
 ids = identifier comma;
 
 unalt_aux = assign_unalterable valor;
 
 tipo =  {base} tipo_base
 		|{vetor} tipo_base vector vecdim+; 		
 
 tipo_base = {int} inttype 
 			|{real} realtype 
 			|{symbol} symboltype; 
 
 unalt = {id} identifier
   |{vetor} identifier vecdim+; 

 cap_aux = variavel comma;
 show_aux = expr comma;
 else_aux = else comando;
 
 long_as = long as;		   

 expr {-> expr} = 
  {equals} equals	 									{-> equals.expr}
 |{and} [left]:expr and [right]:equals 					{-> New expr.and(left.expr, right.expr)}
 |{or} [left]:expr or [right]:equals					{-> New expr.or(left.expr, right.expr)}
 |{xor} [left]:expr xor [right]:equals					{-> New expr.xor(left.expr, right.expr)}
 ;


 equals {-> expr } =
  {rel} rel												{-> rel.expr}
 |{equal} [left]:equals equal [right]:rel				{-> New expr.equal(left.expr, right.expr)}
 |{negation} [left]:equals negation [right]:rel			{-> New expr.negation(left.expr, right.expr)}
 ;

 rel {-> expr} =
  {expr} exp 											{-> exp.expr}
 |{le} [left]:rel le [right]:exp						{-> New expr.le(left.expr, right.expr)}
 |{leq} [left]:rel leq [right]:exp						{-> New expr.leq(left.expr, right.expr)}
 |{bg} [left]:rel bg [right]:exp						{-> New expr.bg(left.expr, right.expr)}
 |{beq} [left]:rel beq [right]:exp						{-> New expr.beq(left.expr, right.expr)}
 ;

 exp {-> expr} =
   {fator} fator 										{-> fator.expr}
  |{soma} [left]:exp plus [right]:fator 				{-> New expr.soma(left.expr, right.expr)}
  |{menos} [left]:exp minus [right]:fator				{-> New expr.menos(left.expr, right.expr)}
  ;

 fator {-> expr} =
   {termo} termo 										{-> termo.expr}
  |{mult} [left]:fator mult [right]:termo 				{-> New expr.mult(left.expr, right.expr)} 
  |{div} [left]:fator div [right]:termo 				{-> New expr.div(left.expr, right.expr)}
  |{mod} [left]:fator mod [right]:termo					{-> New expr.mod(left.expr, right.expr)}
  ;

/* Transforma-los em unario

 termo {-> expr} =
 {numero} numero										{-> numero.expr}
 |{minus} minus numero									{-> New expr.minus(numero)}
 |{not} not numero										{-> New expr.not(numero)}
 ;

 numero {-> expr} =
   {valor} valor 										{-> New expr.valor(valor)}
  |{variavel} variavel									{-> New expr.variavel(variavel)}
  |{par} l_par expr r_par								{-> New expr.par(expr)}																		
  ;
  
*/ 

  
  termo {-> expr} =
 	|{minus} minus expr									{-> New expr.minus(expr)}
	|{not} not expr										{-> New expr.not(expr)}
 	|{valor} valor 										
  	|{variavel} variavel								
  	|{par} l_par expr r_par								{-> New expr.par(expr)}		 
  ;
  
    
  valor =
   {sym} symbol
   | {int} integer
   | {real} real
   | {string} string;  
   
   variavel =
   {id} identifier
   |{vetor} identifier vecdim+; 
  
  vecdim = lbracket expr rbracket;

 comando =  {aberto} comando_com_else | {fechado} comando_sem_else; 
 
 comando_com_else = {comando} outro
 	| {else} in case that l_par expr r_par do [left]:comando_com_else else [right]:comando_com_else
 	|{considering} considering variavel from [left]:expr to [center]:expr by [right]:expr do comando_com_else
	|{as_long} as long_as l_par expr r_par do comando_com_else;
 
 comando_sem_else = {comandos} in case that l_par expr r_par do comando
 	| {else} in case that l_par expr r_par do [right]:comando_com_else else [left]:comando_sem_else
 	|{considering} considering variavel from [left]:expr to [center]:expr by [right]:expr do comando_sem_else
	|{as_long} as long_as l_par expr r_par do comando_sem_else;
 
 outro = {bloco} bloco
 		   |{var_atr} variavel assign expr end
 		   |{unalt} unalt assign_unalterable expr end 
 		   |{cap} capture l_par cap_aux* variavel r_par end
 		   |{show} show l_par show_aux* expr r_par end;

Abstract Syntax Tree

/*

    programa =
     code identifier bloco 
     ;

    bloco =
     start declaracao* comando* finish 
     ;

    declaracao =
     {variavel} tipo ids* identifier end | 
     {constant} unalterable tipo identifier unalt_aux end 
     ;

    ids =
     identifier comma 
     ;

    unalt_aux =
     assign_unalterable valor 
     ;

    tipo =
     {base} tipo_base | 
     {vetor} tipo_base vector vecdim+ 
     ;

    tipo_base =
     {int} inttype | 
     {real} realtype | 
     {symbol} symboltype 
     ;

    unalt =
     {id} identifier | 
     {vetor} identifier vecdim+ 
     ;

    cap_aux =
     variavel comma 
     ;

    show_aux =
     expr comma 
     ;

    else_aux =
     else comando 
     ;

    long_as =
     long as 
     ;
     
*/  
     
/*

serao transformados em um so
    exp =
     {equals} equals | 
     {and} exp and equals | 
     {or} exp or equals | 
     {xor} exp xor equals 
     ;

    equals =
     {rel} rel | 
     {equal} equals equal rel | 
     {negation} equals negation rel 
     ;

    rel =
     {expr} exp | 
     {le} rel le exp | 
     {leq} rel leq exp | 
     {bg} rel bg exp | 
     {beq} rel beq exp 
     ;
*/



   expr = 
     {and} [left]:expr 			[right]:expr | 
     {or} [left]:expr			[right]:expr | 
     {xor} [left]:expr 			[right]:expr |
     {equal} [left]:expr 		[right]:expr | 
     {negation} [left]:expr 	[right]:expr |
     {le} [left]:expr 			[right]:expr | 
     {leq} [left]:expr 			[right]:expr | 
     {bg} [left]:expr 			[right]:expr | 
     {beq} [left]:expr 			[right]:expr |
     {soma} [left]:expr 		[right]:expr |
 	 {menos} [left]:expr 		[right]:expr |
 	 {div} [left]:expr 			[right]:expr |
 	 {mult} [left]:expr 		[right]:expr |
 	 {mod} [left]:expr  		[right]:expr |
 	 {minus} expr 				 			|
 	 {not} expr 					 		|
 	 {valor} valor							|
 	 {variavel} variavel					|
 	 {par} expr
	;
	
	
/*
    exp =
     {fator} fator | 
     {soma} exp plus fator | 
     {menos} exp minus fator 
     ;

    fator =
     {termo} termo | 
     {mult} fator mult termo | 
     {div} fator div termo | 
     {mod} fator mod termo 
     ;

    termo =
     {pos} numero | 
     {neg} minus numero | 
     {sw} minus numero | 
     {not} not numero 
     ;

*/

    numero =
     {valor} valor | 
     {variavel} variavel | 
     {par} l_par expr r_par 
     ;

    valor =
     {sym} symbol | 
     {int} integer | 
     {real} real | 
     {string} string 
     ;

    variavel =
     {id} identifier | 
     {vetor} identifier vecdim+ 
     ;

    vecdim =
     lbracket expr rbracket 
     ;
/*


    comando =
     {aberto} comando_com_else | 
     {fechado} comando_sem_else 
     ;

    comando_com_else =
     {comando} outro | 
     {else} in case that l_par expr r_par do [left]: comando_com_else else [right]: comando_com_else | 
     {considering} considering variavel from expr to exp by numero do comando_com_else | 
     {as_long} as long_as l_par expr r_par do comando_com_else 
     ;

    comando_sem_else =
     {comandos} in case that l_par expr r_par do comando | 
     {else} in case that l_par expr r_par do [right]: comando_com_else else [left]: comando_sem_else | 
     {considering} considering variavel from expr to exp by numero do comando_sem_else | 
     {as_long} as long_as l_par expr r_par do comando_sem_else 
     ;
     
*/     

/*

    outro =
     {bloco} bloco | 
     {var_atr} variavel assign expr end | 
     {unalt} unalt assign_unalterable expr end | 
     {cap} capture l_par cap_aux* variavel r_par end | 
     {show} show l_par show_aux* expr r_par end 
     ;  
 
*/  
  
/*

Referencias para as precedencias de operadores:

http://www.inf.ufpr.br/danielw/grad/ci067/20092/op-prec.html

https://pt.wikipedia.org/wiki/Operadores_em_C_e_C%2B%2B

*/





